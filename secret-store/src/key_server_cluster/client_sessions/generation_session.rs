// Copyright 2015-2020 Parity Technologies (UK) Ltd.
// This file is part of Parity Secret Store.

// Parity Secret Store is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// Parity Secret Store is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with Parity Secret Store.  If not, see <http://www.gnu.org/licenses/>.

use std::collections::{BTreeSet, BTreeMap, VecDeque};
use std::fmt::{Debug, Formatter, Error as FmtError};
use std::sync::Arc;
use futures::Oneshot;
use parking_lot::Mutex;
use ethereum_types::{H256, Address};
use crypto::publickey::{Public, Secret};
use key_server_cluster::{Error, NodeId, SessionId, KeyStorage, DocumentKeyShare, DocumentKeyShareVersion};
use key_server_cluster::math;
use key_server_cluster::cluster::Cluster;
use key_server_cluster::cluster_sessions::{ClusterSession, CompletionSignal};
use key_server_cluster::random_point_generation_session::{SessionImpl as RandomPointGenerationSession, SessionTransport as RandomPointGenerationSessionTransport};
use key_server_cluster::message::{Message, GenerationMessage, InitializeSession, ConfirmInitialization,
	DerivedPointGeneration, RandomPointGenerationMessage, KeysDissemination, PublicKeyShare, SessionError, SessionCompleted, JointPublicKey};

/// Distributed key generation session.
/// Based on "ECDKG: A Distributed Key Generation Protocol Based on Elliptic Curve Discrete Logarithm" paper:
/// http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.124.4128&rep=rep1&type=pdf
/// Brief overview:
/// 1) initialization: master node (which has received request for generating joint public + secret) initializes the session on all other nodes
/// 2) key dissemination (KD): all nodes are generating secret + public values and send these to appropriate nodes
/// 3) key verification (KV): all nodes are checking values, received for other nodes
/// 4) key generation phase (KG): nodes are exchanging with information, enough to generate joint public key
pub struct SessionImpl {
	/// Unique session id.
	id: SessionId,
	/// Public identifier of this node.
	self_node_id: NodeId,
	/// Key storage.
	key_storage: Option<Arc<dyn KeyStorage>>,
	/// Cluster which allows this node to send messages to other nodes in the cluster.
	cluster: Arc<dyn Cluster>,
	/// Session-level nonce.
	nonce: u64,
	/// Mutable session data.
	data: Mutex<SessionData>,
	/// Session completion signal.
	completed: CompletionSignal<Public>,
}

/// SessionImpl creation parameters
pub struct SessionParams {
	/// SessionImpl identifier.
	pub id: SessionId,
	/// Id of node, on which this session is running.
	pub self_node_id: Public,
	/// Key storage.
	pub key_storage: Option<Arc<dyn KeyStorage>>,
	/// Cluster
	pub cluster: Arc<dyn Cluster>,
	/// Session nonce.
	pub nonce: Option<u64>,
}

/// Mutable data of distributed key generation session.
#[derive(Debug)]
struct SessionData {
	/// Current state of the session.
	state: SessionState,
	/// Simulate faulty behaviour?
	simulate_faulty_behaviour: bool,

	// === Values, filled when session initialization just starts ===
	/// Reference to the node, which has started this session.
	master: Option<NodeId>,
	/// Address of the creator of the session.
	author: Option<Address>,

	// === Values, filled when session initialization is completed ===
	/// Session origin (if any).
	origin: Option<Address>,
	/// Is zero secret generation session?
	is_zero: Option<bool>,
	/// Threshold value for this DKG. Only `threshold + 1` will be able to collectively recreate joint secret,
	/// and thus - decrypt message, encrypted with joint public.
	threshold: Option<usize>,
	/// Derived point generation session.
	derived_point_generation: RandomPointGenerationSession,
	/// Nodes-specific data.
	nodes: BTreeMap<NodeId, NodeData>,

	// === Values, filled during KD phase ===
	/// Polynom1.
	polynom1: Option<Vec<Secret>>,
	/// Value of polynom1[0], generated by this node.
	secret_coeff: Option<Secret>,

	// === Values, filled during KG phase ===
	/// Hash of all (ordered) publics of all nodes that were used in computation.
	publics_footprint: Option<H256>,
	/// Joint public that we have computed locally.
	joint_public: Option<Public>,
	/// Hash of all (ordered) public shares received from all nodes. 
	joint_public_footprint: Option<H256>,
	/// Secret share, which this node holds. Persistent + private.
	secret_share: Option<Secret>,

	/// === Values, filled when DKG session is completed successfully ===
	/// Key share.
	key_share: Option<Result<DocumentKeyShare, Error>>,
	/// Jointly generated public key, which can be used to encrypt secret. Public.
	joint_public_and_secret: Option<Result<(Public, Secret, Secret), Error>>,
}

/// Mutable node-specific data.
#[derive(Debug, Clone)]
struct NodeData {
	/// True if node has confirmed initialization.
	pub initialized: bool,
	/// Random unique scalar. Persistent.
	pub id_number: Secret,

	// === Values, filled during KD phase ===
	/// Secret value1, which has been received from this node.
	pub secret1: Option<Secret>,
	/// Secret value2, which has been received from this node.
	pub secret2: Option<Secret>,
	/// Public values, which have been received from this node.
	pub publics: Option<Vec<Public>>,

	// === Values, filled during KG phase ===
	/// Public share, which has been received from this node.
	pub public_share: Option<Public>,
	pub coefficient_commitments: Option<Vec<Public>>,

	// === Values, filled during completion phase ===
	/// Flags marking that node has confirmed key joint public compution.
	pub joint_computed: bool,
	/// Flags marking that node has confirmed session completion (generated key is stored).
	pub completion_confirmed: bool,
}

/// Schedule for visiting other nodes of cluster.
#[derive(Debug, Clone, PartialEq)]
pub struct EveryOtherNodeVisitor {
	/// Already visited nodes.
	visited: BTreeSet<NodeId>,
	/// Not yet visited nodes.
	unvisited: VecDeque<NodeId>,
	/// Nodes, which are currently visited.
	in_progress: BTreeSet<NodeId>,
}

/// Derived point generation session transport.
struct DerivedPointGenerationTransport {
	/// Unique session id.
	id: SessionId,
	/// Session-level nonce.
	nonce: u64,
	/// Cluster which allows this node to send messages to other nodes in the cluster.
	cluster: Arc<dyn Cluster>,
}

/// Distributed key generation session state.
#[derive(Debug, Clone, PartialEq)]
pub enum SessionState {
	// === Initialization states ===
	/// Every node starts in this state.
	WaitingForInitialization,
	/// Master node waits for initialization confirmation from all other nodes.
	WaitingForInitializationConfirm,
	/// Waiting for random derived point generation.
	WaitingForDerivedPointGeneration,

	// === KD phase states ===
	/// Node is waiting for generated keys from every other node.
	WaitingForKeysDissemination,

	// === KG phase states ===
	/// Node is waiting for joint public key share to be received from every other node.
	WaitingForPublicKeyShare,
	/// Waiting for joint public key confirmation.
	WaitingForJointPublic,

	// === Generation phase states ===
	/// Node is waiting for session completion/session completion confirmation.
	WaitingForGenerationConfirmation,

	// === Final states of the session ===
	/// Joint public key generation is completed.
	Finished,
	/// Joint public key generation is failed.
	Failed,
}

pub enum InitializationNodes {
	RandomNumbers(BTreeSet<NodeId>),
	SpecificNumbers(BTreeMap<NodeId, Secret>)
}

impl InitializationNodes {
	pub fn set(&self) -> BTreeSet<NodeId> {
		match *self {
			InitializationNodes::RandomNumbers(ref nodes) => nodes.clone(),
			InitializationNodes::SpecificNumbers(ref nodes) => nodes.keys().cloned().collect(),
		}
	}
}

impl From<BTreeSet<NodeId>> for InitializationNodes {
	fn from(nodes: BTreeSet<NodeId>) -> Self {
		InitializationNodes::RandomNumbers(nodes)
	}
}

impl From<BTreeMap<NodeId, Secret>> for InitializationNodes {
	fn from(nodes: BTreeMap<NodeId, Secret>) -> Self {
		InitializationNodes::SpecificNumbers(nodes)
	}
}

impl SessionImpl {

	//TODO remove me
	pub fn state_str(&self) -> String {
		format!("{:?}", self.data.lock().state)
	}

	/// Create new generation session.
	pub fn new(params: SessionParams) -> (Self, Oneshot<Result<Public, Error>>) {
		let (completed, oneshot) = CompletionSignal::new();
		let nonce = params.nonce.unwrap_or_default();
		(SessionImpl {
			id: params.id,
			self_node_id: params.self_node_id,
			key_storage: params.key_storage,
			cluster: params.cluster.clone(),
			// when nonce.is_nonce(), generation session is wrapped
			// => nonce is checked somewhere else && we can pass any value
			nonce,
			completed,
			data: Mutex::new(SessionData {
				state: SessionState::WaitingForInitialization,
				simulate_faulty_behaviour: false,
				master: None,
				author: None,
				origin: None,
				is_zero: None,
				threshold: None,
				derived_point_generation: RandomPointGenerationSession::new(
					params.self_node_id,
					Arc::new(DerivedPointGenerationTransport {
						id: params.id,
						nonce,
						cluster: params.cluster,
					}),
				),
				nodes: BTreeMap::new(),
				polynom1: None,
				secret_coeff: None,
				publics_footprint: None,
				joint_public: None,
				joint_public_footprint: None,
				secret_share: None,
				key_share: None,
				joint_public_and_secret: None,
			}),
		}, oneshot)
	}

	/// Get this node Id.
	pub fn node(&self) -> &NodeId {
		&self.self_node_id
	}

	/// Simulate faulty generation session behaviour.
	pub fn simulate_faulty_behaviour(&self) {
		self.data.lock().simulate_faulty_behaviour = true;
	}

	/// Get session state.
	pub fn state(&self) -> SessionState {
		self.data.lock().state.clone()
	}

	/// Get session origin.
	pub fn origin(&self) -> Option<Address> {
		self.data.lock().origin.clone()
	}

	/// Get session completion result (if available).
	pub fn result(&self) -> Option<Result<Public, Error>> {
		self.data.lock().joint_public_and_secret.clone()
			.map(|r| r.map(|r| r.0.clone()))
	}

	/// Get generated public and secret (if any).
	pub fn joint_public_and_secret(&self) -> Option<Result<(Public, Secret, Secret), Error>> {
		self.data.lock().joint_public_and_secret.clone()
	}

	/// Start new session initialization. This must be called on master node.
	pub fn initialize(&self, origin: Option<Address>, author: Address, is_zero: bool, threshold: usize, nodes: InitializationNodes) -> Result<(), Error> {
		check_cluster_nodes(self.node(), &nodes.set())?;
		check_threshold(threshold, &nodes.set())?;

		let mut data = self.data.lock();

		// check state
		if data.state != SessionState::WaitingForInitialization {
			return Err(Error::InvalidStateForRequest);
		}

		// update state
		data.master = Some(self.node().clone());
		data.author = Some(author.clone());
		data.origin = origin.clone();
		data.is_zero = Some(is_zero);
		data.threshold = Some(threshold);
		match nodes {
			InitializationNodes::RandomNumbers(nodes) => {
				for node_id in nodes {
					// generate node identification parameter
					let node_id_number = math::generate_random_scalar()?;
					data.nodes.insert(node_id, NodeData::with_id_number(node_id == self.self_node_id, node_id_number));
				}
			},
			InitializationNodes::SpecificNumbers(nodes) => {
				for (node_id, node_id_number) in nodes {
					data.nodes.insert(node_id, NodeData::with_id_number(node_id == self.self_node_id, node_id_number));
				}
			},
		}

		// if we are single node
		if data.nodes.len() == 1 {
			let participants = data.nodes.keys().cloned().collect();
			data.derived_point_generation.start(participants)?;
			drop(data);
			self.disseminate_keys()?;
			self.verify_keys()?;
			self.compute_joint_public()?;
			self.complete_generation()?;

			let mut data = self.data.lock();
			let result = data.joint_public_and_secret.clone()
				.expect("session is instantly completed on a single node; qed")
				.map(|(p, _, _)| p);
			data.state = SessionState::Finished;
			self.completed.send(result);

			return Ok(());
		}

		// initialize session on other nodes
		data.state = SessionState::WaitingForInitializationConfirm;
		self.cluster.broadcast(Message::Generation(GenerationMessage::InitializeSession(
			InitializeSession {
				session: self.id.clone().into(),
				session_nonce: self.nonce,
				origin: origin.map(Into::into),
				author: author.into(),
				nodes: data.nodes.iter().map(|(k, v)| (k.clone().into(), v.id_number.clone().into())).collect(),
				is_zero: data.is_zero.expect("is_zero is filled in initialization phase; KD phase follows initialization phase; qed"),
				threshold: data.threshold.expect("threshold is filled in initialization phase; KD phase follows initialization phase; qed"),
			},
		)))?;

		Ok(())
	}

	/// Process single message.
	pub fn process_message(&self, sender: &NodeId, message: &GenerationMessage) -> Result<(), Error> {
		if self.nonce != message.session_nonce() {
			return Err(Error::ReplayProtection);
		}

		match message {
			&GenerationMessage::InitializeSession(ref message) =>
				self.on_initialize_session(sender.clone(), message),
			&GenerationMessage::ConfirmInitialization(ref message) =>
				self.on_confirm_initialization(sender.clone(), message),
			&GenerationMessage::DerivedPointGeneration(ref message) =>
				self.on_derived_point_generation(sender.clone(), message),
			&GenerationMessage::KeysDissemination(ref message) =>
				self.on_keys_dissemination(sender.clone(), message),
			&GenerationMessage::PublicKeyShare(ref message) =>
				self.on_public_key_share(sender.clone(), message),
			&GenerationMessage::JointPublicKey(ref message) =>
				self.on_joint_public_key(sender.clone(), message),
			&GenerationMessage::SessionError(ref message) => {
				self.on_session_error(sender, message.error.clone());
				Ok(())
			},
			&GenerationMessage::SessionCompleted(ref message) =>
				self.on_session_completed(sender.clone(), message),
		}
	}

	/// When session initialization message is received.
	pub fn on_initialize_session(&self, sender: NodeId, message: &InitializeSession) -> Result<(), Error> {
		debug_assert!(self.id == *message.session);
		debug_assert!(&sender != self.node());

		// check message
		let nodes_ids = message.nodes.keys().cloned().map(Into::into).collect();
		check_threshold(message.threshold, &nodes_ids)?;
		check_cluster_nodes(self.node(), &nodes_ids)?;

		let mut data = self.data.lock();

		// check state
		if data.state != SessionState::WaitingForInitialization {
			return Err(Error::InvalidStateForRequest);
		}

		// send confirmation back to master node
		self.cluster.send(&sender, Message::Generation(GenerationMessage::ConfirmInitialization(ConfirmInitialization {
			session: self.id.clone().into(),
			session_nonce: self.nonce,
		})))?;

		// update state
		data.master = Some(sender);
		data.author = Some(message.author.clone().into());
		data.state = SessionState::WaitingForDerivedPointGeneration;
		data.nodes = message.nodes.iter().map(|(id, number)| (id.clone().into(), NodeData::with_id_number(true, number.clone().into()))).collect();
		data.origin = message.origin.clone().map(Into::into);
		data.is_zero = Some(message.is_zero);
		data.threshold = Some(message.threshold);

		Ok(())
	}

	/// When session initialization confirmation message is received.
	pub fn on_confirm_initialization(&self, sender: NodeId, message: &ConfirmInitialization) -> Result<(), Error> {
		debug_assert!(self.id == *message.session);
		debug_assert!(&sender != self.node());

		let mut data = self.data.lock();

		// check state && select new node to be initialized
		match data.state {
			SessionState::WaitingForInitializationConfirm => (),
			_ => return Err(Error::InvalidStateForRequest),
		}

		// update node data
		{
			let node_data = data.nodes.get_mut(&sender).ok_or(Error::InvalidMessage)?;
			if node_data.initialized {
				return Err(Error::InvalidMessage);
			}
			node_data.initialized = true;
		}

		// if all nodes have confirmed initialization, start derived point generation
		if data.nodes.values().any(|nd| !nd.initialized) {
			return Ok(());
		}

		let participants = data.nodes.keys().cloned().collect();
		data.state = SessionState::WaitingForDerivedPointGeneration;
		data.derived_point_generation.start(participants)
	}

	/// When derived point generation message is received.
	pub fn on_derived_point_generation(
		&self,
		sender: NodeId,
		message: &DerivedPointGeneration,
	) -> Result<(), Error> {
		debug_assert!(self.id == *message.session);
		debug_assert!(&sender != self.node());

		let mut data = self.data.lock();

		// check state
		match data.state {
			SessionState::WaitingForDerivedPointGeneration => (),
			_ => return Err(Error::InvalidStateForRequest),
		}

		// process message
		if !data.derived_point_generation.is_started() {
			let participants = data.nodes.keys().cloned().collect();
			data.derived_point_generation.start(participants)?;
		}
		data.derived_point_generation.process_message(&sender, &message.message)?;

		// if derived point generation has completed, proceed to the next state
		if data.derived_point_generation.generated_point().is_none() {
			return Ok(());
		}

		// start keys dissemination
		drop(data);
		self.disseminate_keys()
	}

	/// When keys dissemination message is received.
	pub fn on_keys_dissemination(&self, sender: NodeId, message: &KeysDissemination) -> Result<(), Error> {
		debug_assert!(self.id == *message.session);
		debug_assert!(&sender != self.node());

		let mut data = self.data.lock();

		// simulate failure, if required
		if data.simulate_faulty_behaviour {
			return Err(Error::Internal("simulated error".into()));
		}

		// check state
		match data.state {
			SessionState::WaitingForDerivedPointGeneration => return Err(Error::TooEarlyForRequest),
			SessionState::WaitingForKeysDissemination => (),
			_ => return Err(Error::InvalidStateForRequest),
		}
		debug_assert!(data.nodes.contains_key(&sender));

		// check message
		let is_zero = data.is_zero.expect("is_zero is filled in initialization phase; KD phase follows initialization phase; qed");
		let threshold = data.threshold.expect("threshold is filled in initialization phase; KD phase follows initialization phase; qed");
		if !is_zero && message.publics.len() != threshold + 1 {
			return Err(Error::InvalidMessage);
		}

		// update node data
		{
			let node_data = data.nodes.get_mut(&sender).ok_or(Error::InvalidMessage)?;
			if node_data.secret1.is_some() || node_data.secret2.is_some() || node_data.publics.is_some() {
				return Err(Error::InvalidStateForRequest);
			}

			node_data.secret1 = Some(message.secret1.clone().into());
			node_data.secret2 = Some(message.secret2.clone().into());
			node_data.publics = Some(message.publics.iter().cloned().map(Into::into).collect());
		}

		// check if we have received keys from every other node
		if data.nodes.values().any(|node_data| node_data.publics.is_none() || node_data.secret1.is_none() || node_data.secret2.is_none()) {
			return Ok(())
		}

		drop(data);
		self.verify_keys()
	}

	/// When public key share is received.
	pub fn on_public_key_share(&self, sender: NodeId, message: &PublicKeyShare) -> Result<(), Error> {
		let mut data = self.data.lock();

		// check state
		if data.state != SessionState::WaitingForPublicKeyShare {
			match data.state {
				SessionState::WaitingForDerivedPointGeneration |
					SessionState::WaitingForKeysDissemination => return Err(Error::TooEarlyForRequest),
				_ => return Err(Error::InvalidStateForRequest),
			}
		}

		// check that the node was working with the same publics that we know of
		let publics_footprint = message.publics_footprint.clone().into();
		let expected_publics_footprint = data.publics_footprint.as_ref()
			.expect("computed n KD phase; we're in KG phase; KG phase follows KD; qed");
		if *expected_publics_footprint != publics_footprint {
			return Err(Error::InvalidMessage);
		}

		// update node data with received public share
		let self_id_number = data.nodes[self.node()].id_number.clone();
		let threshold = data.threshold.expect("threshold is filled in initialization phase; KG phase follows initialization phase; qed");
		let is_zero = data.is_zero.expect("is_zero is filled in initialization phase; KG phase follows initialization phase; qed");
		{
			let node_data = &mut data.nodes.get_mut(&sender).ok_or(Error::InvalidMessage)?;
			if node_data.public_share.is_some() {
				return Err(Error::InvalidMessage);
			}

			// verify public share proof
			let is_share_proof_valid = if !is_zero {
				math::share_proof_verification(
					threshold,
					&self_id_number,
					node_data.secret1.as_ref().expect("keys received on KD phase; KV phase follows KD phase; qed"),
					&message.public_share_proof.iter().cloned().map(Into::into).collect::<Vec<_>>(),
				)?
			} else {
				true
			};
			if !is_share_proof_valid {
				return Err(Error::InvalidMessage);
			}

			node_data.public_share = Some(message.public_share_proof[0].clone().into());
			node_data.coefficient_commitments = Some(message.public_share_proof.iter().map(|p| p.clone().into()).collect());
		}

		// if there's also nodes, which has not sent us their public shares - do nothing
		if data.nodes.values().any(|node_data| node_data.public_share.is_none()) {
			return Ok(());
		}

		drop(data);
		self.compute_joint_public()
	}

	/// When public key is computed.
	pub fn on_joint_public_key(&self, sender: NodeId, message: &JointPublicKey) -> Result<(), Error> {
		let mut data = self.data.lock();

		// check state
		match data.state {
			SessionState::WaitingForPublicKeyShare => return Err(Error::TooEarlyForRequest),
			SessionState::WaitingForJointPublic => (),
			_ => return Err(Error::InvalidStateForRequest),
		}

		// check that we both have received same input data from other nodes
		let expected_joint_public_footprint = data.joint_public_footprint.as_ref()
			.expect("computed in WaitingForPublicKeyShare state; we have already passed this state; qed");
		if *expected_joint_public_footprint != message.joint_public_footprint.clone().into() {
			return Err(Error::InvalidMessage);
		}

		// remember that the node has confirmed generation
		{
			let node_data = &mut data.nodes.get_mut(&sender).ok_or(Error::InvalidMessage)?;
			if node_data.joint_computed {
				return Err(Error::InvalidMessage);
			}

			node_data.joint_computed = true;
		}

		// if there's also nodes, which have not yet confirmed joint publice - do nothing
		if data.nodes.values().any(|node_data| !node_data.joint_computed) {
			return Ok(());
		}

		drop(data);
		self.complete_generation()
	}

	/// When session completion message is received.
	pub fn on_session_completed(&self, sender: NodeId, message: &SessionCompleted) -> Result<(), Error> {
		debug_assert!(self.id == *message.session);
		debug_assert!(&sender != self.node());

		let mut data = self.data.lock();
		debug_assert!(data.nodes.contains_key(&sender));

		// check state
		match data.state {
			SessionState::WaitingForJointPublic => return Err(Error::TooEarlyForRequest),
			SessionState::WaitingForGenerationConfirmation => (),
			_ => return Err(Error::InvalidStateForRequest),
		}

		// if we are not masters, save result and respond with confirmation
		if data.master.as_ref() != Some(self.node()) {
			// check that we have received message from master
			if data.master.as_ref() != Some(&sender) {
				return Err(Error::InvalidMessage);
			}

			// calculate joint public key
			let is_zero = data.is_zero.expect("is_zero is filled in initialization phase; KG phase follows initialization phase; qed");
			let joint_public = if !is_zero {
				let public_shares = data.nodes.values().map(|n| n.public_share.as_ref().expect("keys received on KD phase; KG phase follows KD phase; qed"));
				math::compute_joint_public(public_shares)?
			} else {
				Default::default()
			};
			let coefficient_commitments = if !is_zero {
				Some(compute_coefficient_commitments(data.nodes.values())?)
			}else{
				None
			};

			// save encrypted data to key storage
			let encrypted_data = DocumentKeyShare {
				author: data.author.as_ref().expect("author is filled in initialization phase; KG phase follows initialization phase; qed").clone(),
				threshold: data.threshold.expect("threshold is filled in initialization phase; KG phase follows initialization phase; qed"),
				public: joint_public,
				common_point: None,
				encrypted_point: None,
				versions: vec![DocumentKeyShareVersion::new(
					data.nodes.iter().map(|(node_id, node_data)| (node_id.clone(), node_data.id_number.clone())).collect(),
					data.secret_share.as_ref().expect("secret_share is filled in KG phase; we are at the end of KG phase; qed").clone(),
					coefficient_commitments,
				)],
			};

			if let Some(ref key_storage) = self.key_storage {
				key_storage.insert(self.id.clone(), encrypted_data.clone())?;
			}

			// then respond with confirmation
			data.state = SessionState::Finished;
			return self.cluster.send(&sender, Message::Generation(GenerationMessage::SessionCompleted(SessionCompleted {
				session: self.id.clone().into(),
				session_nonce: self.nonce,
			})));
		}

		// remember that we have received confirmation from sender node
		{
			let sender_node = data.nodes.get_mut(&sender).expect("node is always qualified by himself; qed");
			if sender_node.completion_confirmed {
				return Err(Error::InvalidMessage);
			}

			sender_node.completion_confirmed = true;
		}

		// check if we have received confirmations from all cluster nodes
		if data.nodes.iter().any(|(_, node_data)| !node_data.completion_confirmed) {
			return Ok(())
		}

		// we have received enough confirmations => complete session
		let result = data.joint_public_and_secret.clone()
			.expect("we're on master node; we have received last completion confirmation; qed")
			.map(|(p, _, _)| p);
		data.state = SessionState::Finished;
		self.completed.send(result);

		Ok(())
	}

	/// Keys dissemination (KD) phase
	fn disseminate_keys(&self) -> Result<(), Error> {
		let mut data = self.data.lock();

		// pick 2t + 2 random numbers as polynomial coefficients for 2 polynoms
		let threshold = data.threshold.expect("threshold is filled on initialization phase; KD phase follows initialization phase; qed");
		let is_zero = data.is_zero.expect("is_zero is filled on initialization phase; KD phase follows initialization phase; qed");
		let mut polynom1 = math::generate_random_polynom(threshold)?;
		if is_zero {
			polynom1[0] = math::zero_scalar();
		}
		let polynom2 = math::generate_random_polynom(threshold)?;
		data.polynom1 = Some(polynom1.clone());
		data.secret_coeff = Some(polynom1[0].clone());

		// compute t+1 public values
		let publics = match is_zero {
			false => math::public_values_generation(threshold,
				&data.derived_point_generation.generated_point().expect("keys dissemination occurs after derived point is agreed; qed"),
				&polynom1,
				&polynom2)?,
			true => Default::default(),
		};

		// compute secret values for every other node
		for (node, node_data) in data.nodes.iter_mut() {
			let secret1 = math::compute_polynom(&polynom1, &node_data.id_number)?;
			let secret2 = math::compute_polynom(&polynom2, &node_data.id_number)?;

			// send a message containing secret1 && secret2 to other node
			if node != self.node() {
				self.cluster.send(&node, Message::Generation(GenerationMessage::KeysDissemination(KeysDissemination {
					session: self.id.clone().into(),
					session_nonce: self.nonce,
					secret1: secret1.into(),
					secret2: secret2.into(),
					publics: publics.iter().cloned().map(Into::into).collect(),
				})))?;
			} else {
				node_data.secret1 = Some(secret1);
				node_data.secret2 = Some(secret2);
				node_data.publics = Some(publics.clone());
			}
		}

		// update state
		data.state = SessionState::WaitingForKeysDissemination;

		Ok(())
	}

	/// Keys verification (KV) phase
	fn verify_keys(&self) -> Result<(), Error> {
		let mut data = self.data.lock();

		// key verification (KV) phase: check that other nodes have passed correct secrets
		let threshold = data.threshold.expect("threshold is filled in initialization phase; KV phase follows initialization phase; qed");
		let is_zero = data.is_zero.expect("is_zero is filled in initialization phase; KV phase follows initialization phase; qed");
		let self_public_share = {
			if !is_zero {
				let derived_point = data.derived_point_generation.generated_point().expect("derived point generated on initialization phase; KV phase follows initialization phase; qed");
				let number_id = data.nodes[self.node()].id_number.clone();
				for (_, node_data) in data.nodes.iter_mut().filter(|&(node_id, _)| node_id != self.node()) {
					let secret1 = node_data.secret1.as_ref().expect("keys received on KD phase; KV phase follows KD phase; qed");
					let secret2 = node_data.secret2.as_ref().expect("keys received on KD phase; KV phase follows KD phase; qed");
					let publics = node_data.publics.as_ref().expect("keys received on KD phase; KV phase follows KD phase; qed");
					let is_key_verification_ok = math::keys_verification(threshold, &derived_point, &number_id,
						secret1, secret2, publics)?;

					if !is_key_verification_ok {
						// node has sent us incorrect values. In original ECDKG protocol we should have sent complaint here.
						return Err(Error::InvalidMessage);
					}
				}

				// calculate public share
				let self_public_share = {
					let self_secret_coeff = data.secret_coeff.as_ref().expect("secret_coeff is generated on KD phase; KG phase follows KD phase; qed");
					math::compute_public_share(self_secret_coeff)?
				};

				self_public_share
			} else {
				// TODO [Trust]: add verification when available
				Default::default()
			}
		};

		// calculate self secret + public shares
		let self_secret_share = {
			let secret_values_iter = data.nodes.values()
				.map(|n| n.secret1.as_ref().expect("keys received on KD phase; KG phase follows KD phase; qed"));
			math::compute_secret_share(secret_values_iter)?
		};

		// prepare publics footprint and public share proof
		let publics_footprint = math::compute_publics_footprint(
			data
				.nodes
				.iter()
				.map(|(node, node_data)| (
					node.clone(),
					node_data.publics.clone().expect("keys received on KD phase; KG phase follows KD phase; qed"),
				))
				.collect(),
		)?;
		let public_share_proof = if !is_zero {
			math::prepare_share_proof(
				data.polynom1.as_ref().expect("polynom1 is generated on KD phase; KG phase follows KD phase; qed"),
			)?
		} else {
			vec![self_public_share]
		};

		// update state
		data.state = SessionState::WaitingForPublicKeyShare;
		data.secret_share = Some(self_secret_share);
		data.publics_footprint = Some(publics_footprint);
		let self_node = data.nodes.get_mut(self.node()).expect("node is always qualified by himself; qed");
		self_node.public_share = Some(self_public_share.clone());
		self_node.coefficient_commitments = Some(public_share_proof.clone());

		// broadcast self public key share
		self.cluster.broadcast(Message::Generation(GenerationMessage::PublicKeyShare(PublicKeyShare {
			session: self.id.clone().into(),
			session_nonce: self.nonce,
			publics_footprint: publics_footprint.into(),
			public_share_proof: public_share_proof.into_iter().map(Into::into).collect(),
		})))
	}

	/// Compute joint public key.
	fn compute_joint_public(&self) -> Result<(), Error> {
		let mut data = self.data.lock();

		// calculate joint public key
		let is_zero = data.is_zero.expect("is_zero is filled in initialization phase; KG phase follows initialization phase; qed");
		let joint_public = if !is_zero {
			let public_shares = data.nodes.values().map(|n| n.public_share.as_ref().expect("keys received on KD phase; KG phase follows KD phase; qed"));
			math::compute_joint_public(public_shares)?
		} else {
			Default::default()
		};

		// compute joint public footprint
		let joint_public_footprint = math::compute_publics_footprint(
			data.nodes
				.iter()
				.map(|(id, node_data)| (
					id.clone(),
					vec![
						node_data
							.public_share
							.clone()
							.expect("keys received on KD phase; KG phase follows KD phase; qed"),
						]
				))
				.collect(),
		)?;

		// 
		let self_node = data.nodes.get_mut(self.node()).expect("node is always qualified by himself; qed");
		self_node.joint_computed = true;

		// broadcast joint public key to be sure that all nodes have used the same input data
		data.state = SessionState::WaitingForJointPublic;
		data.joint_public = Some(joint_public);
		data.joint_public_footprint = Some(joint_public_footprint);
		self.cluster.broadcast(Message::Generation(GenerationMessage::JointPublicKey(JointPublicKey {
			session: self.id.clone().into(),
			session_nonce: self.nonce,
			joint_public_footprint: joint_public_footprint.into(),
		})))
	}

	/// Complete generation.
	fn complete_generation(&self) -> Result<(), Error> {
		let mut data = self.data.lock();
		let is_zero = data.is_zero.expect("is_zero is filled in initialization phase; KG phase follows initialization phase; qed");

		// compute coefficient commitments
		let coefficient_commitments = if !is_zero {
			Some(compute_coefficient_commitments(data.nodes.values())?)
		}else{
			None
		};

		// prepare key data
		let joint_public = data.joint_public.clone().expect("joint public is filled in the beginning of KG phase; we're at the end of KG phase; qed");
		let secret_share = data.secret_share.as_ref().expect("secret_share is filled in KG phase; we are at the end of KG phase; qed").clone();
		let encrypted_data = DocumentKeyShare {
			author: data.author.as_ref().expect("author is filled in initialization phase; KG phase follows initialization phase; qed").clone(),
			threshold: data.threshold.expect("threshold is filled in initialization phase; KG phase follows initialization phase; qed"),
			public: joint_public,
			common_point: None,
			encrypted_point: None,
			versions: vec![DocumentKeyShareVersion::new(
				data.nodes.iter().map(|(node_id, node_data)| (node_id.clone(), node_data.id_number.clone())).collect(),
				secret_share.clone(),
				coefficient_commitments,
			)],
		};

		// if we are at the slave node - wait for session completion
		let secret_coeff = data.secret_coeff.as_ref().expect("secret coeff is selected on initialization phase; current phase follows initialization; qed").clone();
		if data.master.as_ref() != Some(self.node()) {
			data.key_share = Some(Ok(encrypted_data));
			data.joint_public_and_secret = Some(Ok((joint_public, secret_coeff, secret_share)));
			data.state = SessionState::WaitingForGenerationConfirmation;
			return Ok(());
		}

		// then save encrypted data to the key storage
		if let Some(ref key_storage) = self.key_storage {
			key_storage.insert(self.id.clone(), encrypted_data.clone())?;
		}

		// then distribute encrypted data to every other node
		self.cluster.broadcast(Message::Generation(GenerationMessage::SessionCompleted(SessionCompleted {
			session: self.id.clone().into(),
			session_nonce: self.nonce,
		})))?;

		// then wait for confirmation from all other nodes
		{
			let self_node = data.nodes.get_mut(self.node()).expect("node is always qualified by himself; qed");
			self_node.completion_confirmed = true;
		}
		data.key_share = Some(Ok(encrypted_data));
		data.joint_public_and_secret = Some(Ok((joint_public, secret_coeff, secret_share)));
		data.state = SessionState::WaitingForGenerationConfirmation;

		Ok(())
	}
}

fn compute_coefficient_commitments<'a, I: Iterator<Item=&'a NodeData>>(node_data: I) -> Result<Vec<Public>, Error> {
	let coefficient_commitments = node_data.map(|n| {
		n.coefficient_commitments.as_ref().expect("keys received on KD phase; KG phase follows KD phase; qed")
	});
	math::compute_coefficient_commitments(coefficient_commitments)
}

impl ClusterSession for SessionImpl {
	type Id = SessionId;
	type CreationData = ();
	type SuccessfulResult = Public;

	fn type_name() -> &'static str {
		"generation"
	}

	fn id(&self) -> SessionId {
		self.id.clone()
	}

	fn is_finished(&self) -> bool {
		let data = self.data.lock();
		data.state == SessionState::Failed
			|| data.state == SessionState::Finished
	}

	fn on_node_timeout(&self, node: &NodeId) {
		let mut data = self.data.lock();

		// all nodes are required for generation session
		// => fail without check
		warn!("{}: generation session failed because {} connection has timeouted", self.node(), node);

		data.state = SessionState::Failed;
		data.key_share = Some(Err(Error::NodeDisconnected));
		data.joint_public_and_secret = Some(Err(Error::NodeDisconnected));
		self.completed.send(Err(Error::NodeDisconnected));
	}

	fn on_session_timeout(&self) {
		let mut data = self.data.lock();

		warn!("{}: generation session failed with timeout", self.node());

		data.state = SessionState::Failed;
		data.key_share = Some(Err(Error::NodeDisconnected));
		data.joint_public_and_secret = Some(Err(Error::NodeDisconnected));
		self.completed.send(Err(Error::NodeDisconnected));
	}

	fn on_session_error(&self, node: &NodeId, error: Error) {
		// error in generation session is considered fatal
		// => broadcast error if error occured on this node
		if *node == self.self_node_id {
			// do not bother processing send error, as we already processing error
			let _ = self.cluster.broadcast(Message::Generation(GenerationMessage::SessionError(SessionError {
				session: self.id.clone().into(),
				session_nonce: self.nonce,
				error: error.clone().into(),
			})));
		}

		let mut data = self.data.lock();
		data.state = SessionState::Failed;
		data.key_share = Some(Err(error.clone()));
		data.joint_public_and_secret = Some(Err(error.clone()));
		self.completed.send(Err(error));
	}

	fn on_message(&self, sender: &NodeId, message: &Message) -> Result<(), Error> {
		match *message {
			Message::Generation(ref message) => self.process_message(sender, message),
			_ => unreachable!("cluster checks message to be correct before passing; qed"),
		}
	}
}

impl NodeData {
	fn with_id_number(initialized: bool, node_id_number: Secret) -> Self {
		NodeData {
			initialized,
			id_number: node_id_number,
			secret1: None,
			secret2: None,
			publics: None,
			public_share: None,
			joint_computed: false,
			completion_confirmed: false,
			coefficient_commitments: None,
		}
	}
}

impl Debug for SessionImpl {
	fn fmt(&self, f: &mut Formatter) -> Result<(), FmtError> {
		write!(f, "Generation session {} on {}", self.id, self.self_node_id)
	}
}

fn check_cluster_nodes(self_node_id: &NodeId, nodes: &BTreeSet<NodeId>) -> Result<(), Error> {
	assert!(nodes.contains(self_node_id));
	Ok(())
}

fn check_threshold(threshold: usize, nodes: &BTreeSet<NodeId>) -> Result<(), Error> {
	// at least threshold + 1 nodes are required to collectively decrypt message
	if threshold >= nodes.len() {
		return Err(Error::NotEnoughNodesForThreshold);
	}

	Ok(())
}

impl RandomPointGenerationSessionTransport for DerivedPointGenerationTransport {
	fn send(&self, node: &NodeId, message: RandomPointGenerationMessage) -> Result<(), Error> {
		self.cluster.send(node, Message::Generation(GenerationMessage::DerivedPointGeneration(
			DerivedPointGeneration {
				session: self.id.into(),
				session_nonce: self.nonce,
				message,
			}
		)))
	}
}

#[cfg(test)]
pub mod tests {
	use std::sync::Arc;
	use ethereum_types::H256;
	use crypto::publickey::{Random, Generator, KeyPair, Secret};
	use key_server_cluster::{NodeId, Error, KeyStorage, SessionId};
	use key_server_cluster::message::{self, KeysDissemination, PublicKeyShare, ConfirmInitialization};
	use key_server_cluster::cluster::tests::{MessageLoop as ClusterMessageLoop, make_clusters_and_preserve_sessions};
	use key_server_cluster::cluster_sessions::ClusterSession;
	use key_server_cluster::generation_session::{SessionImpl, SessionState};
	use key_server_cluster::math;
	use key_server_cluster::math::tests::do_encryption_and_decryption;
	use ServerKeyId;

	#[derive(Debug)]
	pub struct MessageLoop(pub ClusterMessageLoop);

	impl MessageLoop {
		pub fn new(num_nodes: usize) -> Self {
			MessageLoop(make_clusters_and_preserve_sessions(num_nodes))
		}

		pub fn init(self, threshold: usize) -> Result<Self, Error> {
			self.0.cluster(0).client().new_generation_session(SessionId::from([1u8; 32]), None, Default::default(), threshold)
				.map(|_| self)
		}

		pub fn session_at(&self, idx: usize) -> Arc<SessionImpl> {
			self.0.sessions(idx).generation_sessions.first().unwrap()
		}

		pub fn session_of(&self, node: &NodeId) -> Arc<SessionImpl> {
			self.0.sessions_of(node).generation_sessions.first().unwrap()
		}

		pub fn nodes_id_numbers(&self) -> Vec<Secret> {
			let session = self.session_at(0);
			let session_data = session.data.lock();
			session_data.nodes.values().map(|n| n.id_number.clone()).collect()
		}

		pub fn nodes_secret_shares(&self) -> Vec<Secret> {
			(0..self.0.nodes().len()).map(|i| {
				let session = self.session_at(i);
				let session_data = session.data.lock();
				session_data.secret_share.as_ref().unwrap().clone()
			}).collect()
		}

		pub fn compute_key_pair(&self) -> KeyPair {
			let server_key_id = ServerKeyId::from([1u8; 32]);
			let t = self.0.key_storage(0).get(&server_key_id).unwrap().unwrap().threshold;
			let secret_shares = self.nodes_secret_shares();
			let id_numbers = self.nodes_id_numbers();
			let secret_shares = secret_shares.iter().take(t + 1).collect::<Vec<_>>();
			let id_numbers = id_numbers.iter().take(t + 1).collect::<Vec<_>>();
			let joint_secret = math::compute_joint_secret_from_shares(t, &secret_shares, &id_numbers).unwrap();

			KeyPair::from_secret(joint_secret).unwrap()
		}

		pub fn key_version(&self) -> H256 {
			let server_key_id = ServerKeyId::from([1u8; 32]);
			self.0.key_storage(0).get(&server_key_id)
				.unwrap().unwrap().versions.iter().last().unwrap().hash
		}
	}

	#[test]
	fn initializes_in_cluster_of_single_node() {
		MessageLoop::new(1).init(0).unwrap();
	}

	#[test]
	fn fails_to_initialize_if_threshold_is_wrong() {
		assert_eq!(MessageLoop::new(2).init(2).unwrap_err(), Error::NotEnoughNodesForThreshold);
	}

	#[test]
	fn fails_to_initialize_when_already_initialized() {
		let ml = MessageLoop::new(2).init(0).unwrap();
		assert_eq!(
			ml.session_at(0).initialize(Default::default(), Default::default(), false, 0, ml.0.nodes().into()),
			Err(Error::InvalidStateForRequest),
		);
	}

	#[test]
	fn fails_to_accept_initialization_when_already_initialized() {
		let ml = MessageLoop::new(2).init(0).unwrap();
		let (from, to, msg) = ml.0.take_message().unwrap();
		ml.0.process_message(from, to, msg.clone());
		assert_eq!(
			ml.session_of(&to).on_message(&from, &msg),
			Err(Error::InvalidStateForRequest),
		);
	}

	#[test]
	fn fails_to_accept_initialization_confirmation_if_already_accepted_from_the_same_node() {
		let ml = MessageLoop::new(3).init(0).unwrap();
		ml.session_of(&ml.0.node(0)).data.lock().state = SessionState::WaitingForInitializationConfirm;
		ml.session_of(&ml.0.node(0)).data.lock().nodes.get_mut(&ml.0.node(1)).unwrap().initialized = true;
		assert_eq!(
			ml.session_of(&ml.0.node(0))
				.on_confirm_initialization(
					ml.0.node(1),
					&ConfirmInitialization {
						session: SessionId::from([1u8; 32]).into(),
						session_nonce: 0,
					}),
			Err(Error::InvalidMessage),
		);
	}

	#[test]
	fn fails_to_accept_initialization_confirmation_if_initialization_already_completed() {
		let ml = MessageLoop::new(2).init(0).unwrap();
		ml.0.take_and_process_message();
		ml.0.take_and_process_message();
		assert_eq!(ml.session_at(0).on_confirm_initialization(ml.0.node(1), &message::ConfirmInitialization {
			session: [1u8; 32].into(),
			session_nonce: 0,
		}), Err(Error::InvalidStateForRequest));
	}

	#[test]
	fn fails_to_accept_keys_dissemination_if_not_waiting_for_it() {
		let ml = MessageLoop::new(2).init(0).unwrap();
		assert_eq!(ml.session_at(0).on_keys_dissemination(ml.0.node(1), &message::KeysDissemination {
			session: [1u8; 32].into(),
			session_nonce: 0,
			secret1: math::generate_random_scalar().unwrap().into(),
			secret2: math::generate_random_scalar().unwrap().into(),
			publics: vec![math::generate_random_point().unwrap().into()],
		}), Err(Error::InvalidStateForRequest));
	}

	#[test]
	fn fails_to_accept_keys_dissemination_if_wrong_number_of_publics_passed() {
		let ml = MessageLoop::new(3).init(0).unwrap();
		ml.session_of(&ml.0.node(0)).data.lock().state = SessionState::WaitingForKeysDissemination;
		assert_eq!(
			ml.session_of(&ml.0.node(0))
				.on_keys_dissemination(
					ml.0.node(1),
					&KeysDissemination {
						session: SessionId::from([1u8; 32]).into(),
						session_nonce: 0,
						secret1: [1u8; 32].into(),
						secret2: [1u8; 32].into(),
						publics: vec![],
					}),
			Err(Error::InvalidMessage),
		);
	}

	#[test]
	fn fails_to_accept_keys_dissemination_second_time_from_the_same_node() {
		let ml = MessageLoop::new(3).init(0).unwrap();
		ml.session_of(&ml.0.node(0)).data.lock().state = SessionState::WaitingForKeysDissemination;
		ml.session_of(&ml.0.node(0)).data.lock().nodes.get_mut(&ml.0.node(1)).unwrap().secret1 = Some([1u8; 32].into());
		assert_eq!(
			ml.session_of(&ml.0.node(0))
				.on_keys_dissemination(
					ml.0.node(1),
					&KeysDissemination {
						session: SessionId::from([1u8; 32]).into(),
						session_nonce: 0,
						secret1: [1u8; 32].into(),
						secret2: [1u8; 32].into(),
						publics: vec![
							NodeId::from([1u8; 64]).into(),
							NodeId::from([2u8; 64]).into(),
						],
					}),
			Err(Error::InvalidMessage),
		);
	}

	#[test]
	fn should_not_accept_public_key_share_when_is_not_waiting_for_it() {
		let ml = MessageLoop::new(3).init(1).unwrap();
		assert_eq!(ml.session_at(0).on_public_key_share(ml.0.node(1), &message::PublicKeyShare {
			session: [1u8; 32].into(),
			session_nonce: 0,
			publics_footprint: H256::default().into(),
			public_share_proof: Vec::new(),
		}), Err(Error::InvalidStateForRequest));
	}

	#[test]
	fn should_not_accept_public_key_share_when_receiving_twice() {
		let ml = MessageLoop::new(3).init(0).unwrap();
		ml.session_of(&ml.0.node(0)).data.lock().state = SessionState::WaitingForPublicKeyShare;
		ml.session_of(&ml.0.node(0)).data.lock().publics_footprint = Some(H256::default());
		ml.session_of(&ml.0.node(0)).data.lock().nodes.get_mut(&ml.0.node(1)).unwrap().public_share = Some(Default::default());
		assert_eq!(
			ml.session_of(&ml.0.node(0))
				.on_public_key_share(
					ml.0.node(1),
					&PublicKeyShare {
						session: SessionId::from([1u8; 32]).into(),
						session_nonce: 0,
						publics_footprint: H256::default().into(),
						public_share_proof: Vec::new(),
					}),
			Err(Error::InvalidMessage),
		);
	}

	#[test]
	fn encryption_fails_on_session_timeout() {
		let ml = MessageLoop::new(2).init(0).unwrap();
		assert!(ml.session_at(0).joint_public_and_secret().is_none());
		ml.session_at(0).on_session_timeout();
		assert_eq!(ml.session_at(0).joint_public_and_secret().unwrap(), Err(Error::NodeDisconnected));
	}

	#[test]
	fn encryption_fails_on_node_timeout() {
		let ml = MessageLoop::new(2).init(0).unwrap();
		assert!(ml.session_at(0).joint_public_and_secret().is_none());
		ml.session_at(0).on_node_timeout(&ml.0.node(1));
		assert_eq!(ml.session_at(0).joint_public_and_secret().unwrap(), Err(Error::NodeDisconnected));
	}

	#[test]
	fn complete_enc_dec_session() {
		let test_cases = [(0, 5), (2, 5), (3, 5)];
		for &(threshold, num_nodes) in &test_cases {
			let ml = MessageLoop::new(num_nodes).init(threshold).unwrap();
			ml.0.loop_until(|| ml.0.is_empty());

			// check that all nodes has finished joint public generation
			let joint_public_key = ml.session_at(0).joint_public_and_secret().unwrap().unwrap().0;
			for i in 0..num_nodes {
				let session = ml.session_at(i);
				assert_eq!(session.state(), SessionState::Finished);
				assert_eq!(session.joint_public_and_secret().map(|p| p.map(|p| p.0)), Some(Ok(joint_public_key)));
			}

			// now let's encrypt some secret (which is a point on EC)
			let document_secret_plain = Random.generate().public().clone();
			let all_nodes_id_numbers = ml.nodes_id_numbers();
			let all_nodes_secret_shares = ml.nodes_secret_shares();
			let document_secret_decrypted = do_encryption_and_decryption(threshold, &joint_public_key,
				&all_nodes_id_numbers,
				&all_nodes_secret_shares,
				None,
				document_secret_plain.clone()
			).0;
			assert_eq!(document_secret_plain, document_secret_decrypted);
		}
	}

	#[test]
	fn generation_message_fails_when_nonce_is_wrong() {
		let ml = MessageLoop::new(2).init(0).unwrap();
		ml.0.take_and_process_message();

		let msg = message::GenerationMessage::KeysDissemination(message::KeysDissemination {
			session: [1u8; 32].into(),
			session_nonce: 10,
			secret1: math::generate_random_scalar().unwrap().into(),
			secret2: math::generate_random_scalar().unwrap().into(),
			publics: vec![math::generate_random_point().unwrap().into()],
		});
		assert_eq!(ml.session_at(1).process_message(&ml.0.node(0), &msg).unwrap_err(), Error::ReplayProtection);
	}
}
